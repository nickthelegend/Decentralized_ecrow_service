#pragma version 10
intcblock 1 0 10 32
bytecblock 0x696e765f 0x 0x3a

// This TEAL was generated by TEALScript v0.105.4
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,string)void
*abi_route_createApplication:
	// company: string
	txna ApplicationArgs 2
	extract 2 0

	// adminAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (adminAddress) for createApplication must be a address
	assert

	// execute createApplication(address,string)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(adminAddress: Address, company: string): void
createApplication:
	proto 2 0

	// contracts/DepartmentsContract.algo.ts:24
	// assert(this.app.id == 0, "This method can only be called during application creation")
	txna Applications 0
	intc 1 // 0
	==

	// This method can only be called during application creation
	assert

	// contracts/DepartmentsContract.algo.ts:27
	// this.admin.value = adminAddress
	pushbytes 0x61646d696e // "admin"
	frame_dig -1 // adminAddress: Address
	app_global_put

	// contracts/DepartmentsContract.algo.ts:28
	// this.companyName.value = company
	pushbytes 0x636f6d70616e794e616d65 // "companyName"
	frame_dig -2 // company: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts/DepartmentsContract.algo.ts:29
	// this.lastUpdated.value = globals.latestTimestamp
	pushbytes 0x6c61737455706461746564 // "lastUpdated"
	global LatestTimestamp
	app_global_put

	// contracts/DepartmentsContract.algo.ts:32
	// log("Inventory DApp created for: " + company)
	pushbytes 0x496e76656e746f72792044417070206372656174656420666f723a20 // "Inventory DApp created for: "
	frame_dig -2 // company: string
	concat
	log
	retsub

// registerDepartment(string,address)void
*abi_route_registerDepartment:
	// manager: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (manager) for registerDepartment must be a address
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute registerDepartment(string,address)void
	callsub registerDepartment
	intc 0 // 1
	return

// registerDepartment(name: string, manager: Address): void
registerDepartment:
	proto 2 0

	// contracts/DepartmentsContract.algo.ts:38
	// assert(this.txn.sender == this.app.creator, "Only company admin can register departments.")
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only company admin can register departments.
	assert

	// contracts/DepartmentsContract.algo.ts:39
	// assert(!this.departments(name).exists, "Department already exists.")
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_len
	swap
	pop
	!

	// Department already exists.
	assert

	// contracts/DepartmentsContract.algo.ts:41
	// this.departments(name).value = {
	//       manager: manager,
	//     }
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	frame_dig -2 // manager: Address
	box_put

	// contracts/DepartmentsContract.algo.ts:45
	// log("Department registered: " + name)
	pushbytes 0x4465706172746d656e7420726567697374657265643a20 // "Department registered: "
	frame_dig -1 // name: string
	concat
	log
	retsub

// addInventory(string,string,uint64)void
*abi_route_addInventory:
	// quantity: uint64
	txna ApplicationArgs 3
	btoi

	// product: string
	txna ApplicationArgs 2
	extract 2 0

	// department: string
	txna ApplicationArgs 1
	extract 2 0

	// execute addInventory(string,string,uint64)void
	callsub addInventory
	intc 0 // 1
	return

// addInventory(department: string, product: string, quantity: uint64): void
addInventory:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/DepartmentsContract.algo.ts:51
	// key = department + ":" + product
	frame_dig -1 // department: string
	bytec 2 //  ":"
	concat
	frame_dig -2 // product: string
	concat
	frame_bury 0 // key: byte[]

	// contracts/DepartmentsContract.algo.ts:52
	// this.departmentInventory(key).value = quantity
	bytec 0 //  "inv_"
	frame_dig 0 // key: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -3 // quantity: uint64
	itob
	box_put
	retsub

// useStock(string,string,uint64)void
*abi_route_useStock:
	// quantity: uint64
	txna ApplicationArgs 3
	btoi

	// product: string
	txna ApplicationArgs 2
	extract 2 0

	// department: string
	txna ApplicationArgs 1
	extract 2 0

	// execute useStock(string,string,uint64)void
	callsub useStock
	intc 0 // 1
	return

// useStock(department: string, product: string, quantity: uint64): void
useStock:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/DepartmentsContract.algo.ts:57
	// assert(this.departments(department).exists, "Department does not exist.")
	frame_dig -1 // department: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_len
	swap
	pop

	// Department does not exist.
	assert

	// contracts/DepartmentsContract.algo.ts:60
	// key = department + ":" + product
	frame_dig -1 // department: string
	bytec 2 //  ":"
	concat
	frame_dig -2 // product: string
	concat
	frame_bury 0 // key: byte[]

	// contracts/DepartmentsContract.algo.ts:63
	// assert(this.departmentInventory(key).exists, "Product not in inventory.")
	bytec 0 //  "inv_"
	frame_dig 0 // key: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop

	// Product not in inventory.
	assert

	// contracts/DepartmentsContract.algo.ts:66
	// currentQuantity = this.departmentInventory(key).value
	bytec 0 //  "inv_"
	frame_dig 0 // key: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.departmentInventory(key).value
	assert
	btoi
	frame_bury 1 // currentQuantity: uint64

	// contracts/DepartmentsContract.algo.ts:67
	// assert(currentQuantity >= quantity, "Insufficient stock available.")
	frame_dig 1 // currentQuantity: uint64
	frame_dig -3 // quantity: uint64
	>=

	// Insufficient stock available.
	assert

	// *if0_condition
	// contracts/DepartmentsContract.algo.ts:70
	// currentQuantity == quantity
	frame_dig 1 // currentQuantity: uint64
	frame_dig -3 // quantity: uint64
	==
	bz *if0_else

	// *if0_consequent
	// contracts/DepartmentsContract.algo.ts:72
	// this.departmentInventory(key).delete()
	bytec 0 //  "inv_"
	frame_dig 0 // key: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_del
	b *if0_end

*if0_else:
	// contracts/DepartmentsContract.algo.ts:75
	// this.departmentInventory(key).value = currentQuantity - quantity
	bytec 0 //  "inv_"
	frame_dig 0 // key: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig 1 // currentQuantity: uint64
	frame_dig -3 // quantity: uint64
	-
	itob
	box_put

*if0_end:
	// contracts/DepartmentsContract.algo.ts:78
	// log("Stock used: " + quantity.toString() + " of " + product + " from " + department)
	pushbytes 0x53746f636b20757365643a20 // "Stock used: "
	frame_dig -3 // quantity: uint64
	callsub *itoa
	concat
	pushbytes 0x206f6620 // " of "
	concat
	frame_dig -2 // product: string
	concat
	pushbytes 0x2066726f6d20 // " from "
	concat
	frame_dig -1 // department: string
	concat
	log
	retsub

*create_NoOp:
	pushbytes 0xf9eecfe4 // method "createApplication(address,string)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xf27c7270 // method "registerDepartment(string,address)void"
	pushbytes 0xfa6bd17d // method "addInventory(string,string,uint64)void"
	pushbytes 0xee9b7d84 // method "useStock(string,string,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_registerDepartment *abi_route_addInventory *abi_route_useStock

	// this contract does not implement the given ABI method for call NoOp
	err

*intToAscii:
	proto 1 1
	pushbytes 0x30313233343536373839 // "0123456789"
	frame_dig -1 // i: uint64
	intc 0 // 1
	extract3
	retsub
	

*itoa:
	proto 1 1
	frame_dig -1 // i: uint64
	intc 1 // 0
	==
	bz *itoa_if_end
	pushbytes 0x30
	retsub

*itoa_if_end:
	frame_dig -1 // i: uint64
	intc 2 // 10
	/
	intc 1 // 0
	>
	bz *itoa_ternary_false
	frame_dig -1 // i: uint64
	intc 2 // 10
	/
	callsub *itoa
	b *itoa_ternary_end

*itoa_ternary_false:
	bytec 1 //  ""

*itoa_ternary_end:
	frame_dig -1 // i: uint64
	intc 2 // 10
	%
	callsub *intToAscii
	concat
	retsub