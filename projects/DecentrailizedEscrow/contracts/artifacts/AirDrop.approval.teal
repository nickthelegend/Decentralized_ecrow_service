#pragma version 10
intcblock 1 0 4
bytecblock 0x61737365744944 0x6e756d436c61696d73 0x616d6f756e74546f53656e64 0x65787069727944617465 0x

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,string,uint64,uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// amountToSend: uint64
	txna ApplicationArgs 7
	btoi

	// expiryDate: uint64
	txna ApplicationArgs 6
	btoi

	// maxClaims: uint64
	txna ApplicationArgs 5
	btoi

	// numClaims: uint64
	txna ApplicationArgs 4
	btoi

	// assetID: uint64
	txna ApplicationArgs 3
	btoi

	// tokenName: string
	txna ApplicationArgs 2
	extract 2 0

	// creatorAddress: address
	txna ApplicationArgs 1
	dup
	len
	pushint 32
	==

	// argument 6 (creatorAddress) for createApplication must be a address
	assert

	// execute createApplication(address,string,uint64,uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(creatorAddress: Address, tokenName: string, assetID: AssetID, numClaims : uint64, maxClaims: uint64, expiryDate : uint64, amountToSend : uint64): void
createApplication:
	proto 7 0

	// contracts\Airdrop.algo.ts:28
	// this.creatorAddress.value = creatorAddress
	pushbytes 0x63726561746f7241646472657373 // "creatorAddress"
	frame_dig -1 // creatorAddress: Address
	app_global_put

	// contracts\Airdrop.algo.ts:29
	// this.tokenName.value = tokenName
	pushbytes 0x746f6b656e4e616d65 // "tokenName"
	frame_dig -2 // tokenName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts\Airdrop.algo.ts:30
	// this.assetID.value = assetID
	bytec 0 //  "assetID"
	frame_dig -3 // assetID: AssetID
	app_global_put

	// contracts\Airdrop.algo.ts:32
	// this.numClaims.value = numClaims
	bytec 1 //  "numClaims"
	frame_dig -4 // numClaims: uint64
	app_global_put

	// contracts\Airdrop.algo.ts:34
	// this.maxClaims.value = maxClaims
	pushbytes 0x6d6178436c61696d73 // "maxClaims"
	frame_dig -5 // maxClaims: uint64
	app_global_put

	// contracts\Airdrop.algo.ts:35
	// this.expiryDate.value = expiryDate
	bytec 3 //  "expiryDate"
	frame_dig -6 // expiryDate: uint64
	app_global_put

	// contracts\Airdrop.algo.ts:37
	// this.amountToSend.value = amountToSend
	bytec 2 //  "amountToSend"
	frame_dig -7 // amountToSend: uint64
	app_global_put
	retsub

// optinAsset()void
*abi_route_optinAsset:
	// execute optinAsset()void
	callsub optinAsset
	intc 0 // 1
	return

// optinAsset(): void
optinAsset:
	proto 0 0

	// contracts\Airdrop.algo.ts:44
	// assert(this.txn.sender == this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts\Airdrop.algo.ts:45
	// sendAssetTransfer({
	//             xferAsset: this.assetID.value,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//         })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts\Airdrop.algo.ts:46
	// xferAsset: this.assetID.value
	bytec 0 //  "assetID"
	app_global_get
	itxn_field XferAsset

	// contracts\Airdrop.algo.ts:47
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts\Airdrop.algo.ts:48
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// fundDrop(axfer)void
*abi_route_fundDrop:
	// assetTxn: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 0 (assetTxn) for fundDrop must be a axfer transaction
	assert

	// execute fundDrop(axfer)void
	callsub fundDrop
	intc 0 // 1
	return

// fundDrop(assetTxn: AssetTransferTxn): void
fundDrop:
	proto 1 0

	// contracts\Airdrop.algo.ts:68
	// assert(this.txn.sender == this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts\Airdrop.algo.ts:69
	// verifyAssetTransferTxn(assetTxn, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -1 // assetTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts\Airdrop.algo.ts:70
	// assert(assetTxn.xferAsset === this.assetID.value, 'asset sent must be same as asset specified for drops')
	frame_dig -1 // assetTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 0 //  "assetID"
	app_global_get
	==

	// asset sent must be same as asset specified for drops
	assert
	retsub

// claimDrop()void
*abi_route_claimDrop:
	// execute claimDrop()void
	callsub claimDrop
	intc 0 // 1
	return

// claimDrop(): void
claimDrop:
	proto 0 0

	// contracts\Airdrop.algo.ts:77
	// assert(this.txn.sender !==  this.app.creator, 'drop creator cannot claim')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	!=

	// drop creator cannot claim
	assert

	// contracts\Airdrop.algo.ts:78
	// assert(this.txn.sender.isOptedInToAsset(this.assetID.value), 'claimant must already be opted-in to token!')
	txn Sender
	bytec 0 //  "assetID"
	app_global_get
	asset_holding_get AssetBalance
	swap
	pop

	// claimant must already be opted-in to token!
	assert

	// contracts\Airdrop.algo.ts:79
	// assert(this.expiryDate.value >= globals.latestTimestamp , 'DROP expired')
	bytec 3 //  "expiryDate"
	app_global_get
	global LatestTimestamp
	>=

	// DROP expired
	assert

	// contracts\Airdrop.algo.ts:80
	// assert(!this.claimedMap(this.txn.sender).exists, 'already claimed')
	txn Sender
	box_len
	swap
	pop
	!

	// already claimed
	assert

	// contracts\Airdrop.algo.ts:82
	// this.claimedMap(this.txn.sender).value =  this.txn.txID as bytes32
	txn Sender
	txn TxID
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 4 // 0x
	b==
	assert
	extract 0 32
	box_put

	// contracts\Airdrop.algo.ts:84
	// this.numClaims.value += 1
	bytec 1 //  "numClaims"
	app_global_get
	intc 0 // 1
	+
	bytec 1 //  "numClaims"
	swap
	app_global_put

	// contracts\Airdrop.algo.ts:86
	// this.sendTokensFromDrop(this.amountToSend.value, this.txn.sender)
	txn Sender
	bytec 2 //  "amountToSend"
	app_global_get
	callsub sendTokensFromDrop
	retsub

// sendTokensFromDrop(amountToSend: uint64, receiver:Address): uint64
//
// Sends a specified amount of tokens from a token drop to the given receiver
// and updates the remaining balance of the drop. If the drop is fully claimed,
// it is removed from the active drops.
//
// @param {uint64} amountToSend - Information about the token drop, including the token type and remaining balance.
// @param {Address} receiver - The address of the recipient who will receive the tokens.
// @return {uint64} The remaining balance of tokens in the token drop after the transfer.
sendTokensFromDrop:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 4 // 0x

	// contracts\Airdrop.algo.ts:100
	// sendAssetTransfer({
	//             xferAsset: this.assetID.value,
	//             assetReceiver: receiver,
	//             assetAmount: amountToSend,
	//         })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts\Airdrop.algo.ts:101
	// xferAsset: this.assetID.value
	bytec 0 //  "assetID"
	app_global_get
	itxn_field XferAsset

	// contracts\Airdrop.algo.ts:102
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// contracts\Airdrop.algo.ts:103
	// assetAmount: amountToSend
	frame_dig -1 // amountToSend: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\Airdrop.algo.ts:107
	// remaining = this.amountRemaining.value - amountToSend
	pushbytes 0x616d6f756e7452656d61696e696e67 // "amountRemaining"
	app_global_get
	frame_dig -1 // amountToSend: uint64
	-
	frame_bury 0 // remaining: uint64

	// contracts\Airdrop.algo.ts:109
	// return remaining
	frame_dig 0 // remaining: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

*create_NoOp:
	pushbytes 0x5e66ade9 // method "createApplication(address,string,uint64,uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3e89bcf8 // method "optinAsset()void"
	pushbytes 0x2c4b71bf // method "fundDrop(axfer)void"
	pushbytes 0x9aeb5ece // method "claimDrop()void"
	txna ApplicationArgs 0
	match *abi_route_optinAsset *abi_route_fundDrop *abi_route_claimDrop

	// this contract does not implement the given ABI method for call NoOp
	err