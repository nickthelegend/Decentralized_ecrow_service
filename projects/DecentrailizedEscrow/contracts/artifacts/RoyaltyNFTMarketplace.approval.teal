#pragma version 10
intcblock 1 0 4 32
bytecblock 0x6e667441737365744944 0x63757272656e744f776e6572 0x63726561746f72 0x7072696365436f6d6d65726369616c 0x70726963654578636c7573697665 0x726f79616c747950657263656e74 0x7072696365506572736f6e616c 0x6578636c7573697665 0x

// This TEAL was generated by TEALScript v0.105.4
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address,uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// royaltyPercent: uint64
	txna ApplicationArgs 5
	btoi

	// priceExclusive: uint64
	txna ApplicationArgs 4
	btoi

	// priceCommercial: uint64
	txna ApplicationArgs 3
	btoi

	// pricePersonal: uint64
	txna ApplicationArgs 2
	btoi

	// creator: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (creator) for createApplication must be a address
	assert

	// execute createApplication(address,uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(creator: Address, pricePersonal: uint64, priceCommercial: uint64, priceExclusive: uint64, royaltyPercent: uint64): void
createApplication:
	proto 5 0

	// contracts/Royalty.algo.ts:28
	// this.pricePersonal.value = pricePersonal
	bytec 6 //  "pricePersonal"
	frame_dig -2 // pricePersonal: uint64
	app_global_put

	// contracts/Royalty.algo.ts:29
	// this.priceCommercial.value = priceCommercial
	bytec 3 //  "priceCommercial"
	frame_dig -3 // priceCommercial: uint64
	app_global_put

	// contracts/Royalty.algo.ts:30
	// this.priceExclusive.value = priceExclusive
	bytec 4 //  "priceExclusive"
	frame_dig -4 // priceExclusive: uint64
	app_global_put

	// contracts/Royalty.algo.ts:31
	// this.royaltyPercent.value = royaltyPercent
	bytec 5 //  "royaltyPercent"
	frame_dig -5 // royaltyPercent: uint64
	app_global_put

	// contracts/Royalty.algo.ts:32
	// this.creator.value = creator
	bytec 2 //  "creator"
	frame_dig -1 // creator: Address
	app_global_put

	// contracts/Royalty.algo.ts:33
	// this.currentOwner.value = creator
	bytec 1 //  "currentOwner"
	frame_dig -1 // creator: Address
	app_global_put

	// contracts/Royalty.algo.ts:34
	// this.nftAssetID.value = AssetID.zeroIndex
	bytec 0 //  "nftAssetID"
	intc 1 // 0
	app_global_put
	retsub

// optIntoNFT(uint64)void
*abi_route_optIntoNFT:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute optIntoNFT(uint64)void
	callsub optIntoNFT
	intc 0 // 1
	return

// optIntoNFT(asset: AssetID): void
optIntoNFT:
	proto 1 0

	// contracts/Royalty.algo.ts:39
	// assert(this.nftAssetID.value === AssetID.zeroIndex)
	bytec 0 //  "nftAssetID"
	app_global_get
	intc 1 // 0
	==
	assert

	// contracts/Royalty.algo.ts:40
	// this.nftAssetID.value = asset
	bytec 0 //  "nftAssetID"
	frame_dig -1 // asset: AssetID
	app_global_put

	// contracts/Royalty.algo.ts:42
	// sendAssetTransfer({
	//       assetReceiver: this.app.address,
	//       xferAsset: asset,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/Royalty.algo.ts:43
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/Royalty.algo.ts:44
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// contracts/Royalty.algo.ts:45
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// buyLicense(pay,string)void
*abi_route_buyLicense:
	// licenseType: string
	txna ApplicationArgs 1
	extract 2 0

	// payment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (payment) for buyLicense must be a pay transaction
	assert

	// execute buyLicense(pay,string)void
	callsub buyLicense
	intc 0 // 1
	return

// buyLicense(payment: PayTxn, licenseType: string): void
buyLicense:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 8 // 0x

	// contracts/Royalty.algo.ts:50
	// verifyPayTxn(payment, {
	//       receiver: this.app.address,
	//     })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// *if0_condition
	// contracts/Royalty.algo.ts:56
	// licenseType === "personal"
	frame_dig -2 // licenseType: string
	pushbytes 0x706572736f6e616c // "personal"
	==
	bz *if0_elseif1_condition

	// *if0_consequent
	// contracts/Royalty.algo.ts:57
	// expectedAmount = this.pricePersonal.value
	bytec 6 //  "pricePersonal"
	app_global_get
	frame_bury 0 // expectedAmount: uint64
	b *if0_end

*if0_elseif1_condition:
	// contracts/Royalty.algo.ts:58
	// licenseType === "commercial"
	frame_dig -2 // licenseType: string
	pushbytes 0x636f6d6d65726369616c // "commercial"
	==
	bz *if0_elseif2_condition

	// *if0_elseif1_consequent
	// contracts/Royalty.algo.ts:59
	// expectedAmount = this.priceCommercial.value
	bytec 3 //  "priceCommercial"
	app_global_get
	frame_bury 0 // expectedAmount: uint64
	b *if0_end

*if0_elseif2_condition:
	// contracts/Royalty.algo.ts:60
	// licenseType ==="exclusive"
	frame_dig -2 // licenseType: string
	bytec 7 //  "exclusive"
	==
	bz *if0_else

	// *if0_elseif2_consequent
	// contracts/Royalty.algo.ts:61
	// expectedAmount = this.priceExclusive.value
	bytec 4 //  "priceExclusive"
	app_global_get
	frame_bury 0 // expectedAmount: uint64
	b *if0_end

*if0_else:
	// contracts/Royalty.algo.ts:63
	// assert(false, "Invalid license type.")
	intc 1 // 0

	// Invalid license type.
	assert

*if0_end:
	// contracts/Royalty.algo.ts:66
	// assert(payment.amount >= this.expectedAmount.value)
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	pushbytes 0x6578706563746564416d6f756e74 // "expectedAmount"
	app_global_get
	>=
	assert

	// contracts/Royalty.algo.ts:68
	// this.buyerLicense.value = licenseType
	pushbytes 0x62757965724c6963656e7365 // "buyerLicense"
	frame_dig -2 // licenseType: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// *if1_condition
	// contracts/Royalty.algo.ts:70
	// licenseType === "exclusive"
	frame_dig -2 // licenseType: string
	bytec 7 //  "exclusive"
	==
	bz *if1_else

	// *if1_consequent
	// contracts/Royalty.algo.ts:72
	// this.transferOwnership(payment.sender)
	frame_dig -1 // payment: PayTxn
	gtxns Sender
	callsub transferOwnership
	b *if1_end

*if1_else:
	// contracts/Royalty.algo.ts:75
	// this.payRoyalty(this.creator.value, payment.amount)
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 2 //  "creator"
	app_global_get
	callsub payRoyalty

*if1_end:
	retsub

// transferOwnership(address)void
*abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (newOwner) for transferOwnership must be a address
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	intc 0 // 1
	return

// transferOwnership(newOwner: Address): void
transferOwnership:
	proto 1 0

	// contracts/Royalty.algo.ts:80
	// sendAssetTransfer({
	//       assetReceiver: newOwner,
	//       xferAsset: this.nftAssetID.value,
	//       assetAmount: 1,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/Royalty.algo.ts:81
	// assetReceiver: newOwner
	frame_dig -1 // newOwner: Address
	itxn_field AssetReceiver

	// contracts/Royalty.algo.ts:82
	// xferAsset: this.nftAssetID.value
	bytec 0 //  "nftAssetID"
	app_global_get
	itxn_field XferAsset

	// contracts/Royalty.algo.ts:83
	// assetAmount: 1
	intc 0 // 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/Royalty.algo.ts:85
	// this.currentOwner.value = newOwner
	bytec 1 //  "currentOwner"
	frame_dig -1 // newOwner: Address
	app_global_put
	retsub

// payRoyalty(address,uint64)void
*abi_route_payRoyalty:
	// amountPaid: uint64
	txna ApplicationArgs 2
	btoi

	// to: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (to) for payRoyalty must be a address
	assert

	// execute payRoyalty(address,uint64)void
	callsub payRoyalty
	intc 0 // 1
	return

// payRoyalty(to: Address, amountPaid: uint64): void
payRoyalty:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 8 // 0x

	// contracts/Royalty.algo.ts:89
	// royaltyAmount = (amountPaid * this.royaltyPercent.value) / 100
	frame_dig -2 // amountPaid: uint64
	bytec 5 //  "royaltyPercent"
	app_global_get
	*
	pushint 100
	/
	frame_bury 0 // royaltyAmount: uint64

	// contracts/Royalty.algo.ts:91
	// sendPayment({
	//       receiver: to,
	//       amount: royaltyAmount,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/Royalty.algo.ts:92
	// receiver: to
	frame_dig -1 // to: Address
	itxn_field Receiver

	// contracts/Royalty.algo.ts:93
	// amount: royaltyAmount
	frame_dig 0 // royaltyAmount: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cancelListing()void
*abi_route_cancelListing:
	// execute cancelListing()void
	callsub cancelListing
	intc 0 // 1
	return

// cancelListing(): void
cancelListing:
	proto 0 0

	// contracts/Royalty.algo.ts:100
	// assert(this.txn.sender === this.creator.value || this.txn.sender === this.currentOwner.value)
	txn Sender
	bytec 2 //  "creator"
	app_global_get
	==
	dup
	bnz *skip_or0
	txn Sender
	bytec 1 //  "currentOwner"
	app_global_get
	==
	||

*skip_or0:
	assert

	// contracts/Royalty.algo.ts:102
	// sendAssetTransfer({
	//       assetReceiver: this.currentOwner.value,
	//       xferAsset: this.nftAssetID.value,
	//       assetAmount: 1,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/Royalty.algo.ts:103
	// assetReceiver: this.currentOwner.value
	bytec 1 //  "currentOwner"
	app_global_get
	itxn_field AssetReceiver

	// contracts/Royalty.algo.ts:104
	// xferAsset: this.nftAssetID.value
	bytec 0 //  "nftAssetID"
	app_global_get
	itxn_field XferAsset

	// contracts/Royalty.algo.ts:105
	// assetAmount: 1
	intc 0 // 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*create_NoOp:
	pushbytes 0x2985eabc // method "createApplication(address,uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x18ca81f5 // method "optIntoNFT(uint64)void"
	pushbytes 0xb0380e7a // method "buyLicense(pay,string)void"
	pushbytes 0xe17bafb4 // method "transferOwnership(address)void"
	pushbytes 0x314b63ae // method "payRoyalty(address,uint64)void"
	pushbytes 0xb2c2b54c // method "cancelListing()void"
	txna ApplicationArgs 0
	match *abi_route_optIntoNFT *abi_route_buyLicense *abi_route_transferOwnership *abi_route_payRoyalty *abi_route_cancelListing

	// this contract does not implement the given ABI method for call NoOp
	err